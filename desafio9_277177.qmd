---
title: "Desafio 9"
author: "Joaquim Bertoldi Nucci - RA: 277177"
format: html
editor: visual
---

```{r}
cat("Relatório gerado em:", format(Sys.time(), "%d/%m/%Y %H:%M:%S"))
```


1. Crie um arquivo de banco de dados em SQLite chamado `voos.sqlite3`. (Dica: o comando `dbConnect()` se conecta num banco de dados se o arquivo apontado existir ou cria um novo, caso o arquivo não exista.)

```{r}
library(RSQLite)
fname = file.path("dados", "voos.sqlite3")
conn = dbConnect(SQLite(), fname)
```


2. Leia os arquivos `airlines.csv` e `airports.csv`. Deposite o conteúdo de cada um destes arquivos nas tabelas, respectivamente, `airlines` e `airports`. Utilize o comando `dbWriteTable()` para isso.

```{r importSmall}
path = "dados"
library(readr)
airlines = read_csv(file.path(path, "airlines.csv"))
airports = read_csv(file.path(path, "airports.csv"))
dbWriteTable(conn, "airlines", airlines, overwrite = TRUE)
dbWriteTable(conn, "airports", airports, overwrite = TRUE)
```


3. Crie uma função chamada `lerDados` contendo 2 argumentos, `input` e `pos`. A função deve apresentar ao usuário uma mensagem de progresso da leitura do arquivo `flights.csv` (utilize o comando `message()`), aos moldes do apresentado abaixo. A função deve salvar apenas os vôos que partiram ou chegaram aos seguintes aeroportos `BWI`, `MIA`, `SEA`, `SFO` e `JFK`, numa tabela chamada `flights`. Observe que a função não deve retornar nada para o usuário, deve apenas gravar a tabela obtida do chunk no banco de dados. (Dica: utilize o comando `dbWriteTable()` e estude como o argumento `append` deve ser utilizado para permitir que os *chunks* intermediários sejam adicionados ao fim da tabela.)

```{r}
pos = 10000
```

```{r fcaoLeitura}
lerDados = function(input, pos){
  tmp = input %>% filter(DESTINATION_AIRPORT %in% c('BWI', 'MIA', 'SEA', 'SFO', 'JFK') | ORIGIN_AIRPORT %in% c('BWI', 'MIA', 'SEA', 'SFO', 'JFK'))
  message("Leitura atingiu a linha ", pos)
  dbWriteTable(conn, "flights", tmp, append=TRUE)
}
```


4. Leia o arquivo `flights.csv`, restringindo-se às colunas `YEAR`, `MONTH`, `DAY`, `AIRLINE`, `FLIGHT_NUMBER`, `ORIGIN_AIRPORT`, `DESTINATION_AIRPORT` e `ARRIVAL_DELAY`, e aplique a função `lerDados()` criada acima. Observe, novamente, que a função `lerDados()` não retorna nada para o usuário. Por isso, a função de callback a ser utilizada é `SideEffectChunkCallback$new()`. Leia 100 mil registros por vez.

```{r loadDB}
library(tidyverse)
fname = file.path(path, "flights.csv")
out = read_csv_chunked(fname, chunk_size = 1e5, callback=SideEffectChunkCallback$new(lerDados),
                 col_types = cols_only(YEAR='i', MONTH='i', DAY='i', AIRLINE='c',
                                       FLIGHT_NUMBER='i', ORIGIN_AIRPORT='c',
                                       DESTINATION_AIRPORT='c', ARRIVAL_DELAY='i'))
```

5. Acesse o banco de dados e, por meio de uma chamada em SQL, apresente o tempo médio de atraso de chegada por aeroporto de destino, a sigla do aeroporto, o nome completo do aeroporto e o nome completo da companhia aérea. Ordene o resultado (na mesma chamada de SQL) por ordem decrescente deste atraso médio (i.e., o primeiro registro deve ser o aeroporto que tem o maior tempo de atraso na chegada). Atente para o fato de que o mesmo nome de coluna pode acontecer em diferentes tabelas.

```{r sql}
dbGetQuery(conn,
           "SELECT DESTINATION_AIRPORT, AIRPORT, airlines.AIRLINE, AVG(ARRIVAL_DELAY) AS atraso FROM flights
           INNER JOIN airports
           ON flights.DESTINATION_AIRPORT=airports.IATA_CODE
           INNER JOIN airlines
           ON flights.AIRLINE=airlines.IATA_CODE
           GROUP BY DESTINATION_AIRPORT, flights.AIRLINE
           ORDER BY atraso DESC")
```

```{r}
dbDisconnect(conn)
```

